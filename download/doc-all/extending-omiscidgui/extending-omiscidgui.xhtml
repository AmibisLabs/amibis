<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <title>OMiSCID Tips and GUI Extension</title>
        <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
    </head>

    <body>
        <div class="presentation">

            <div>
                <h1>OMiSCID Day 2</h1>
                <h2>1) Tips and Tricks (<a href="#slide6">slide 6</a>)</h2>
                <h2>2) Extending the GUI (<a href="#slide17">slide 17</a>)</h2>
            </div>

            <div class="smart">
                ==
                <h2>Quick Reminders</h2>

                =OMiSCID Services=
                <img src="presentation-some-services.png" width="750" height="*"/>

                =OMiSCID API=[iIsAPI]
                * Entry point: <i>ServiceFactory</i>
                * Service creation
                   ** <i>Service</i>: a local service that we create
                * Service discovery
                   ** <i>ServiceRepository</i>: a way to look for running services
                   ** <i>ServiceProxy</i>: a reference to a service running in the environment
                * OMiSCID Messages
                   ** <i>byte[ ]</i> (char* in C): arbitrary binary messages are sent
                   ** <i>Message</i>: received message with String and XML helpers

                =Case Study (<a href="/day1/start-omiscid-day.xhtml#slide12">on day 1</a>)=
                * Face detection service
                * Progressive refinement
                * Last increment
                ** a FaceDetector service
                *** does face detection on-demand
                *** receives a filename on a connector
                *** answers with the list of detected faces (rectangles)
                ** a client
                *** looking for such services
                *** allowing interaction with the service


                =Overview of Day 2=
                * Tips and Tricks
                ** behavior of OMiSCID
                ** service design
                ** a word on computer vision “modules”
                * Extending OMiSCIDGui



                ==
                <h2>OMiSCID Tips and Tricks</h2>
                <h2>OMiSCID Behavior</h2>

                =Threads in OMiSCID (Threading Model)=[iIsImportant]
                * Heavily multi-threaded
                ** possible concurrent access
                ** need for synchronization
                * <i>Only guaranty</i>
                ** <i>two messages sent through the same connection won't be reordered</i>
                ** connection = a link between a (in)output connector of a peer and a in(out)put connector of another peer
                * Tip: handle concurrency, be “too strict” first
                ** C++ mutexes, <br/>Java synchronized and <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/package-summary.html">java.util.concurrent.*</a>
                ** no premature optimization

                =Environment Variables=
                * “Working domain”
                ** default domain: _bip._tcp
                ** OMISCID_WORKING_DOMAIN = _bip_test._tcp
                ** _bip_rem._tcp, _bip_matt._tcp, _bip_sonia._tcp, …
                * Ad'hoc networks
                ** OMISCIDNS_USE_MDNS_NAME_SOLVING = true
                * (Java) Fine tune selection of DNSSD implementation
                ** default: smart runtime selection
                ** OMISCID_DNSSD_FACTORY_VERBOSE_MODE = true
                ** OMISCID_DNSSD_FACTORY
                ** values: mdns, avahi, jmdns




                ==
                <h2>OMiSCID Tips and Tricks</h2>
                <h2>Service Design</h2>

                =Variables, Connectors and Mixes=
                * Tip 1: variable vs connector
                ** variable: a current value
                ** connector: emits/receives messages
                ** variable: metadata about the service
                ** connector: data in and out of the service
                * Tip 2: do not rely on  synchronization
                ** e.g. changing a variable “just before” sending a message
                ** (details later)

                =When to use variables=
                * Variables
                ** expose service state
                ** have string values (utf-8)
                ** can optionally change
                ** can optionally be writable
                * Tip 1: avoid fast-changing variables
                ** &lt; 2 change/s: ok
                ** 2-10 change/s: examine the case
                ** > 10 change/s: change it
                * Tip 2: writable variables
                ** allow dynamic (re)configuration
                ** properly describe your variables

                =Tips About Connectors=
                * Message format
                ** avoid binary
                ** prefer XML
                ** use meaningful atomic values
                ** e.g. <br/><code style="font-size:smaller">&lt;rect left="12" top="55" width="24" height="24"/></code>
                * Client tools
                ** let your service running
                ** … or document your format
                ** share “client libraries” <br/>(e.g. video-service-client)

                =Life Cycle and Interconnections=
                * Whiteboard pattern
                ** “server” does the connection to the “clients”
                ** e.g. in the practical work of day 1
                ** win-win:
                *** no connection code in the clients
                *** forces clients to be services
                * Service Factories
                ** a service that instantiates other services
                ** e.g. FaceDetector with different “cascade.txt” files
                ** recurrent pattern in computer vision


                =About Computer Vision “Modules”=
                * Requirements
                ** multiple processing on a camera
                ** need to reuse processing building blocks
                * Solution
                ** a service factory per camera
                ** a library of modules (building blocks)
                *** e.g. pyramid, adaptive background, …
                ** pipeline descriptors are passed to the factory
                *** e.g. do adaptative background with param1=123 then imDiff then pyramid …

                =About Computer Vision “Modules”=
                <img src="presentation-pipeline-preview.png" width="750" height="*"/>
                * Presentation on this GSP … later
                * Question: diff. between service and module



                ==
                <h1>OMiSCID Day 2</h1>
                <h2>1) Tips and Tricks</h2>
                <h2>2) Extending the GUI</h2>

                =OMiSCIDGui Introduction=
                * Demo
                * Based on the Netbeans platform
                ** modular and extensible
                ** written in Java
                ** using Swing for UI
                * GUI objectives
                ** debugging services
                ** monitoring applications
                ** easily sharing service clients
                ** making demonstrations



                =Overview of Day 2=
                * Tips and Tricks
                * Extending OMiSCIDGui
                ** without extending it
                ** by creating plugins/modules


                =Extending OMiSCIDGui Without Extending It=
                * Use OMiSCID, create services
                ** services automatically appear
                ** variables can be monitored
                ** user can interact with connectors
                * Reuse existing conventions
                ** <a href="http://oberon.inrialpes.fr/mediawiki/index.php/Service_Design_Guidelines">describe</a> your variables (Adrien Maillol)
                ** have a “killService” variable
                ** expose your service as a “ServiceVideo”, …

                
                =How Does a Module End In Your Plate?=
                <img src="presentation-nbms-deployment.png" width="750" height="*"/>
                =How Does a Module End In Your Plate?=
                <img src="presentation-nbms-deployment-2.png" width="750" height="*"/>
                =How Does a Module End In Your Plate?=
                <img src="presentation-nbms-deployment-3.png" width="750" height="*"/>

                =Practical Objective=
                * Creating a .nbm to upload to oberon

                =Architectural Principle of OMiSCIDGui=
                <img src="presentation-selector-based-lookup.png" width="750" height="*"/>

                =Architectural Principle of OMiSCIDGui=
                <img src="presentation-selector-based-lookup-2.png" width="750" height="*"/>

                =Practical Steps=
                * Installation
                ** Download and install Netbeans IDE
                ** Download and install OMiSCIDGui
                ** Tell Netbeans where to find OMiSCIDGui
                * Creation
                ** Create a new project of type “Netbeans Module”
                ** Create your potential selectors, tasks and actions
                ** Register selectors and actions (layer.xml)
                * Release
                ** Set version number and commit
                ** Generate and copy on oberon the nbm file

                ==
                <h1>The Practice…</h1>
                * <a href="DEMOModule.zip">Get zip bundle of the final Netbeans project</a>
                * <a href="DEMOModule/src/fr/prima/omiscidgui/demolive">View the major sources</a>


                ==[lastSlide]
                <h1>The End…</h1>

            </div>
        </div>
    </body>
</html>
